// DO NOT EDIT. Generated by protoc-gen-dart-ext/tools.
/// source: hybrid/config.proto
// ignore_for_file: non_constant_identifier_names,unnecessary_brace_in_string_interps,unused_local_variable

import 'config.pb.dart' as $0
    show
        AdpRouter,
        Basic,
        Config,
        FileServer,
        HttpProxyServer,
        IPNetRouter,
        Ipfs,
        IpfsServer,
        Log,
        RouterItem,
        RouterItem_Router;
import 'package:pgde/pgde.dart' as $1 show ZeroAction;

/// Zero for [$0.Basic] protobuf objects.
const zeroBasic = const _Basic();

class _Basic implements $1.ZeroAction<$0.Basic> {
  const _Basic();

  List<int> get _$bindIp => const <int>[0xff, 0x0, 0x0, 0x1];

  @override
  $0.Basic create() => onZeroCreate($0.Basic());

  @override
  $0.Basic onZeroCreate($0.Basic proto) {
    // no zero rules for proto.version

    // no zero rules for proto.dev

    // no zero rules for proto.enableBind

    if (proto.bindIp.isEmpty) proto.bindIp = _$bindIp;

    if (proto.bindPort == 0) proto.bindPort = 7777;

    if (proto.flushIntervalMs == 0) proto.flushIntervalMs = 200;

    // no zero rules for proto.token

    return proto;
  }

  @override
  $0.Basic onZeroLoad($0.Basic proto) {
    // no zero rules for proto.version

    // no zero rules for proto.dev

    // no zero rules for proto.enableBind

    if (proto.bindIp.isEmpty) proto.bindIp = _$bindIp;

    if (proto.bindPort == 0) proto.bindPort = 7777;

    if (proto.flushIntervalMs == 0) proto.flushIntervalMs = 200;

    // no zero rules for proto.token

    return proto;
  }

  @override
  $0.Basic onZeroSave($0.Basic proto, [$0.Basic _$$_]) {
    // no zero rules for proto.version

    // no zero rules for proto.dev

    // no zero rules for proto.enableBind

    if (proto.bindIp.isEmpty) proto.bindIp = _$bindIp;

    if (proto.bindPort == 0) proto.bindPort = 7777;

    if (proto.flushIntervalMs == 0) proto.flushIntervalMs = 200;

    // no zero rules for proto.token

    return proto;
  }
}

/// Zero for [$0.Log] protobuf objects.
const zeroLog = const _Log();

class _Log implements $1.ZeroAction<$0.Log> {
  const _Log();

  @override
  $0.Log create() => onZeroCreate($0.Log());

  @override
  $0.Log onZeroCreate($0.Log proto) {
    // no zero rules for proto.dev

    // no zero rules for proto.level

    // no zero rules for proto.target

    return proto;
  }

  @override
  $0.Log onZeroLoad($0.Log proto) {
    // no zero rules for proto.dev

    // no zero rules for proto.level

    // no zero rules for proto.target

    return proto;
  }

  @override
  $0.Log onZeroSave($0.Log proto, [$0.Log _$$_]) {
    // no zero rules for proto.dev

    // no zero rules for proto.level

    // no zero rules for proto.target

    return proto;
  }
}

/// Zero for [$0.Ipfs] protobuf objects.
const zeroIpfs = const _Ipfs();

class _Ipfs implements $1.ZeroAction<$0.Ipfs> {
  const _Ipfs();

  List<int> get _$fakeApiListenIp => const <int>[0xff, 0x0, 0xff, 0x1];

  static const _$gatewayServerName = r'ipfs';

  static const _$apiServerName = r'api.ipfs';

  @override
  $0.Ipfs create() => onZeroCreate($0.Ipfs());

  @override
  $0.Ipfs onZeroCreate($0.Ipfs proto) {
    if (proto.fakeApiListenIp.isEmpty)
      proto.fakeApiListenIp = _$fakeApiListenIp;

    if (proto.fakeApiListenPort == 0) proto.fakeApiListenPort = 1270;

    // no zero rules for proto.enableGateway

    if (proto.gatewayServerName.isEmpty)
      proto.gatewayServerName = _$gatewayServerName;

    // no zero rules for proto.enableApi

    if (proto.apiServerName.isEmpty) proto.apiServerName = _$apiServerName;

    // no zero rules for proto.profile

    // no zero rules for proto.autoMigrate

    // no zero rules for proto.enableIpnsPubSub

    // no zero rules for proto.enablePubSub

    // no zero rules for proto.enableMultiplex

    // no zero rules for proto.token

    return proto;
  }

  @override
  $0.Ipfs onZeroLoad($0.Ipfs proto) {
    if (proto.fakeApiListenIp.isEmpty)
      proto.fakeApiListenIp = _$fakeApiListenIp;

    if (proto.fakeApiListenPort == 0) proto.fakeApiListenPort = 1270;

    // no zero rules for proto.enableGateway

    if (proto.gatewayServerName.isEmpty)
      proto.gatewayServerName = _$gatewayServerName;

    // no zero rules for proto.enableApi

    if (proto.apiServerName.isEmpty) proto.apiServerName = _$apiServerName;

    // no zero rules for proto.profile

    // no zero rules for proto.autoMigrate

    // no zero rules for proto.enableIpnsPubSub

    // no zero rules for proto.enablePubSub

    // no zero rules for proto.enableMultiplex

    // no zero rules for proto.token

    return proto;
  }

  @override
  $0.Ipfs onZeroSave($0.Ipfs proto, [$0.Ipfs _$$_]) {
    if (proto.fakeApiListenIp.isEmpty)
      proto.fakeApiListenIp = _$fakeApiListenIp;

    if (proto.fakeApiListenPort == 0) proto.fakeApiListenPort = 1270;

    // no zero rules for proto.enableGateway

    if (proto.gatewayServerName.isEmpty)
      proto.gatewayServerName = _$gatewayServerName;

    // no zero rules for proto.enableApi

    if (proto.apiServerName.isEmpty) proto.apiServerName = _$apiServerName;

    // no zero rules for proto.profile

    // no zero rules for proto.autoMigrate

    // no zero rules for proto.enableIpnsPubSub

    // no zero rules for proto.enablePubSub

    // no zero rules for proto.enableMultiplex

    // no zero rules for proto.token

    return proto;
  }
}

/// Zero for [$0.IpfsServer] protobuf objects.
const zeroIpfsServer = const _IpfsServer();

class _IpfsServer implements $1.ZeroAction<$0.IpfsServer> {
  const _IpfsServer();

  @override
  $0.IpfsServer create() => onZeroCreate($0.IpfsServer());

  @override
  $0.IpfsServer onZeroCreate($0.IpfsServer proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    // no zero rules for proto.peer

    // no zero rules for proto.token

    return proto;
  }

  @override
  $0.IpfsServer onZeroLoad($0.IpfsServer proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    // no zero rules for proto.peer

    // no zero rules for proto.token

    return proto;
  }

  @override
  $0.IpfsServer onZeroSave($0.IpfsServer proto, [$0.IpfsServer _$$_]) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    // no zero rules for proto.peer

    // no zero rules for proto.token

    return proto;
  }
}

/// Zero for [$0.FileServer] protobuf objects.
const zeroFileServer = const _FileServer();

class _FileServer implements $1.ZeroAction<$0.FileServer> {
  const _FileServer();

  @override
  $0.FileServer create() => onZeroCreate($0.FileServer());

  @override
  $0.FileServer onZeroCreate($0.FileServer proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    // no zero rules for proto.zip

    // no zero rules for proto.redirect

    // no zero rules for proto.dev

    return proto;
  }

  @override
  $0.FileServer onZeroLoad($0.FileServer proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    // no zero rules for proto.zip

    // no zero rules for proto.redirect

    // no zero rules for proto.dev

    return proto;
  }

  @override
  $0.FileServer onZeroSave($0.FileServer proto, [$0.FileServer _$$_]) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    // no zero rules for proto.zip

    // no zero rules for proto.redirect

    // no zero rules for proto.dev

    return proto;
  }
}

/// Zero for [$0.HttpProxyServer] protobuf objects.
const zeroHttpProxyServer = const _HttpProxyServer();

class _HttpProxyServer implements $1.ZeroAction<$0.HttpProxyServer> {
  const _HttpProxyServer();

  static const _$host = r'127.0.0.1';

  @override
  $0.HttpProxyServer create() => onZeroCreate($0.HttpProxyServer());

  @override
  $0.HttpProxyServer onZeroCreate($0.HttpProxyServer proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    if (proto.host.isEmpty) proto.host = _$host;

    if (proto.port == 0) proto.port = 8899;

    // no zero rules for proto.keepAlive

    return proto;
  }

  @override
  $0.HttpProxyServer onZeroLoad($0.HttpProxyServer proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    if (proto.host.isEmpty) proto.host = _$host;

    if (proto.port == 0) proto.port = 8899;

    // no zero rules for proto.keepAlive

    return proto;
  }

  @override
  $0.HttpProxyServer onZeroSave($0.HttpProxyServer proto,
      [$0.HttpProxyServer _$$_]) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    if (proto.host.isEmpty) proto.host = _$host;

    if (proto.port == 0) proto.port = 8899;

    // no zero rules for proto.keepAlive

    return proto;
  }
}

/// Zero for [$0.AdpRouter] protobuf objects.
const zeroAdpRouter = const _AdpRouter();

class _AdpRouter implements $1.ZeroAction<$0.AdpRouter> {
  const _AdpRouter();

  @override
  $0.AdpRouter create() => onZeroCreate($0.AdpRouter());

  @override
  $0.AdpRouter onZeroCreate($0.AdpRouter proto) {
    // no zero rules for proto.rulesDirName

    // no zero rules for proto.blocked

    // no zero rules for proto.unblocked

    // no zero rules for proto.etcHostsIpAsBlocked

    // no zero rules for proto.dev

    return proto;
  }

  @override
  $0.AdpRouter onZeroLoad($0.AdpRouter proto) {
    // no zero rules for proto.rulesDirName

    // no zero rules for proto.blocked

    // no zero rules for proto.unblocked

    // no zero rules for proto.etcHostsIpAsBlocked

    // no zero rules for proto.dev

    return proto;
  }

  @override
  $0.AdpRouter onZeroSave($0.AdpRouter proto, [$0.AdpRouter _$$_]) {
    // no zero rules for proto.rulesDirName

    // no zero rules for proto.blocked

    // no zero rules for proto.unblocked

    // no zero rules for proto.etcHostsIpAsBlocked

    // no zero rules for proto.dev

    return proto;
  }
}

/// Zero for [$0.IPNetRouter] protobuf objects.
const zeroIPNetRouter = const _IPNetRouter();

class _IPNetRouter implements $1.ZeroAction<$0.IPNetRouter> {
  const _IPNetRouter();

  @override
  $0.IPNetRouter create() => onZeroCreate($0.IPNetRouter());

  @override
  $0.IPNetRouter onZeroCreate($0.IPNetRouter proto) {
    // no zero rules for proto.ip

    // no zero rules for proto.netv4

    // no zero rules for proto.netv6

    // no zero rules for proto.matched

    // no zero rules for proto.unmatched

    // no zero rules for proto.fileTest

    return proto;
  }

  @override
  $0.IPNetRouter onZeroLoad($0.IPNetRouter proto) {
    // no zero rules for proto.ip

    // no zero rules for proto.netv4

    // no zero rules for proto.netv6

    // no zero rules for proto.matched

    // no zero rules for proto.unmatched

    // no zero rules for proto.fileTest

    return proto;
  }

  @override
  $0.IPNetRouter onZeroSave($0.IPNetRouter proto, [$0.IPNetRouter _$$_]) {
    // no zero rules for proto.ip

    // no zero rules for proto.netv4

    // no zero rules for proto.netv6

    // no zero rules for proto.matched

    // no zero rules for proto.unmatched

    // no zero rules for proto.fileTest

    return proto;
  }
}

/// Zero for [$0.RouterItem] protobuf objects.
const zeroRouterItem = const _RouterItem();

class _RouterItem implements $1.ZeroAction<$0.RouterItem> {
  const _RouterItem();

  @override
  $0.RouterItem create() => onZeroCreate($0.RouterItem());

  @override
  $0.RouterItem onZeroCreate($0.RouterItem proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    switch (proto.whichRouter()) {
      case $0.RouterItem_Router.adp:
        zeroAdpRouter.onZeroCreate(proto.ensureAdp());
        break;
      case $0.RouterItem_Router.ipnet:
        zeroIPNetRouter.onZeroCreate(proto.ensureIpnet());
        break;
      default:
    }
    return proto;
  }

  @override
  $0.RouterItem onZeroLoad($0.RouterItem proto) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    switch (proto.whichRouter()) {
      case $0.RouterItem_Router.adp:
        zeroAdpRouter.onZeroLoad(proto.ensureAdp());
        break;
      case $0.RouterItem_Router.ipnet:
        zeroIPNetRouter.onZeroLoad(proto.ensureIpnet());
        break;
      default:
    }
    return proto;
  }

  @override
  $0.RouterItem onZeroSave($0.RouterItem proto, [$0.RouterItem _$$_]) {
    // no zero rules for proto.disabled

    // no zero rules for proto.name

    switch (proto.whichRouter()) {
      case $0.RouterItem_Router.adp:
        zeroAdpRouter.onZeroSave(proto.ensureAdp());
        break;
      case $0.RouterItem_Router.ipnet:
        zeroIPNetRouter.onZeroSave(proto.ensureIpnet());
        break;
      default:
    }
    return proto;
  }
}

/// Zero for [$0.Config] protobuf objects.
const zeroConfig = const _Config();

class _Config implements $1.ZeroAction<$0.Config> {
  const _Config();

  @override
  $0.Config create() => onZeroCreate($0.Config());

  @override
  $0.Config onZeroCreate($0.Config proto) {
    zeroBasic.onZeroCreate(proto.ensureBasic());

    zeroLog.onZeroCreate(proto.ensureLog());

    zeroIpfs.onZeroCreate(proto.ensureIpfs());

    // no zero rules for proto.ipfsServers

    // no zero rules for proto.fileServers

    // no zero rules for proto.httpProxyServers

    // no zero rules for proto.routers

    return proto;
  }

  @override
  $0.Config onZeroLoad($0.Config proto) {
    zeroBasic.onZeroLoad(proto.ensureBasic());

    zeroLog.onZeroLoad(proto.ensureLog());

    zeroIpfs.onZeroLoad(proto.ensureIpfs());

    // no zero rules for proto.ipfsServers

    // no zero rules for proto.fileServers

    // no zero rules for proto.httpProxyServers

    // no zero rules for proto.routers

    return proto;
  }

  @override
  $0.Config onZeroSave($0.Config proto, [$0.Config _$$_]) {
    zeroBasic.onZeroSave(proto.ensureBasic());

    zeroLog.onZeroSave(proto.ensureLog());

    zeroIpfs.onZeroSave(proto.ensureIpfs());

    // no zero rules for proto.ipfsServers

    // no zero rules for proto.fileServers

    // no zero rules for proto.httpProxyServers

    // no zero rules for proto.routers

    return proto;
  }
}
